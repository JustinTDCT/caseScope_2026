#!/usr/bin/env python3
"""
CaseScope AI Report Validation Engine
Detects hallucinations by checking AI responses against source data
"""

import re
from datetime import datetime


def validate_report(ai_response, original_prompt, case_name='Unknown'):
    """
    Validate AI report for hallucinations
    
    Args:
        ai_response: The markdown text generated by the AI
        original_prompt: The full prompt sent to the AI (including data)
        case_name: Name of the case for context
    
    Returns:
        dict: {
            'passed': bool,
            'errors': list of critical issues,
            'warnings': list of minor issues,
            'stats': dict of validation statistics
        }
    """
    
    validation_results = {
        'passed': True,
        'errors': [],
        'warnings': [],
        'stats': {
            'ips_checked': 0,
            'systems_checked': 0,
            'timestamps_checked': 0,
            'hallucinated_ips': 0,
            'hallucinated_systems': 0,
            'hallucinated_timestamps': 0
        }
    }
    
    # Extract IPs from response and prompt
    response_ips = extract_ips(ai_response)
    prompt_ips = extract_ips(original_prompt)
    
    validation_results['stats']['ips_checked'] = len(response_ips)
    
    # Check for hallucinated IPs
    for ip in response_ips:
        if ip not in prompt_ips:
            validation_results['errors'].append({
                'type': 'hallucinated_ip',
                'value': ip,
                'message': f'IP address {ip} not found in case data'
            })
            validation_results['stats']['hallucinated_ips'] += 1
            validation_results['passed'] = False
    
    # Extract system names (pattern: XXX-XXX-###)
    response_systems = extract_system_names(ai_response)
    prompt_systems = extract_system_names(original_prompt)
    
    validation_results['stats']['systems_checked'] = len(response_systems)
    
    # Check for hallucinated systems
    for system in response_systems:
        if system not in prompt_systems:
            validation_results['errors'].append({
                'type': 'hallucinated_system',
                'value': system,
                'message': f'System name {system} not found in case data'
            })
            validation_results['stats']['hallucinated_systems'] += 1
            validation_results['passed'] = False
    
    # Extract and validate timestamps
    response_timestamps = extract_timestamps(ai_response)
    prompt_timestamps = extract_timestamps(original_prompt)
    
    validation_results['stats']['timestamps_checked'] = len(response_timestamps)
    
    # Check for hallucinated timestamps (allow some tolerance for date formatting)
    for timestamp in response_timestamps:
        # Extract just the date part for comparison
        timestamp_date = extract_date_from_timestamp(timestamp)
        
        # Check if this date exists in any prompt timestamp
        found = False
        for prompt_ts in prompt_timestamps:
            prompt_date = extract_date_from_timestamp(prompt_ts)
            if timestamp_date == prompt_date:
                found = True
                break
        
        if not found and timestamp_date:
            validation_results['warnings'].append({
                'type': 'potentially_hallucinated_timestamp',
                'value': timestamp,
                'message': f'Timestamp {timestamp} may not match case event dates'
            })
            validation_results['stats']['hallucinated_timestamps'] += 1
    
    # Check for "NO DATA" compliance
    if 'NO DATA PRESENT' in ai_response or 'NO DATA' in ai_response:
        validation_results['warnings'].append({
            'type': 'no_data_found',
            'value': 'NO DATA',
            'message': 'Report contains "NO DATA" statements - verify completeness'
        })
    
    # Check report length (should be at least 1000 words for a proper report)
    word_count = len(ai_response.split())
    if word_count < 1000:
        validation_results['warnings'].append({
            'type': 'short_report',
            'value': str(word_count),
            'message': f'Report is only {word_count} words (expected at least 1200)'
        })
    
    return validation_results


def extract_ips(text):
    """Extract all IP addresses from text"""
    ip_pattern = r'\b(?:\d{1,3}\.){3}\d{1,3}\b'
    ips = re.findall(ip_pattern, text)
    
    # Filter out invalid IPs (e.g., 0.0.0.0, 255.255.255.255)
    valid_ips = set()
    for ip in ips:
        octets = [int(x) for x in ip.split('.')]
        if all(0 <= x <= 255 for x in octets):
            # Exclude common false positives
            if ip not in ['0.0.0.0', '255.255.255.255', '127.0.0.1']:
                valid_ips.add(ip)
    
    return valid_ips


def extract_system_names(text):
    """Extract system names (pattern: XXX-XXX-###)"""
    # Match patterns like ENG-DSK-100, PROD-WS-200, etc.
    system_pattern = r'\b[A-Z]{2,}-[A-Z]{2,}-\d+\b'
    systems = set(re.findall(system_pattern, text))
    return systems


def extract_timestamps(text):
    """Extract timestamps from text"""
    # Match various timestamp formats:
    # 2025-10-25 08:30:45
    # 2025-10-25T08:30:45Z
    # 2025-10-25T08:30:45
    # 2025-10-25 08:30:45 UTC
    
    timestamp_patterns = [
        r'\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}(?:\s+UTC)?',  # 2025-10-25 08:30:45 UTC
        r'\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z?',  # 2025-10-25T08:30:45Z
        r'\d{4}-\d{2}-\d{2}'  # Just dates
    ]
    
    timestamps = set()
    for pattern in timestamp_patterns:
        matches = re.findall(pattern, text)
        timestamps.update(matches)
    
    return timestamps


def extract_date_from_timestamp(timestamp):
    """Extract just the date part from a timestamp"""
    # Match YYYY-MM-DD
    date_match = re.match(r'(\d{4}-\d{2}-\d{2})', timestamp)
    if date_match:
        return date_match.group(1)
    return None


def format_validation_results(results):
    """Format validation results for display"""
    if results['passed'] and len(results['warnings']) == 0:
        return '✅ VALIDATED - No issues found'
    elif results['passed'] and len(results['warnings']) > 0:
        return f'⚠️  WARNINGS - {len(results["warnings"])} warnings, but no critical errors'
    else:
        return f'❌ FAILED - {len(results["errors"])} critical errors detected'


def get_validation_badge_color(results):
    """Get color for validation badge"""
    if results['passed'] and len(results['warnings']) == 0:
        return 'success'  # Green
    elif results['passed'] and len(results['warnings']) > 0:
        return 'warning'  # Yellow
    else:
        return 'danger'  # Red

